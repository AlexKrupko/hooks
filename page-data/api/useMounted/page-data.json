{"componentChunkName":"component---node-modules-docpocalypse-gatsby-theme-src-templates-hook-tsx","path":"/api/useMounted","result":{"data":{"docpocalypse":{"id":"ccd0438f-2a5b-5a1d-b0ba-038e32bb1a41","tsType":{"id":"95d95a20-503c-546c-b8e6-1b3134175913","name":"useMounted","kind":64,"kindString":"Function","flags":{"isExported":true},"signatures":[{"id":"388943ea-1a5c-520f-b3d1-e6f91cc69d26","name":"useMounted","kind":4096,"kindString":"Call signature","flags":{"isExported":true},"type":{"type":"reflection","declaration":{"id":"0d27b082-2aab-5c13-820b-f564058945c6","name":"__type","kind":65536,"kindString":"Type literal","flags":{"isExported":true},"signatures":[{"id":"6e3e2058-18e4-5a61-ad57-65a746940eb2","name":"__call","kind":4096,"kindString":"Call signature","flags":{"isExported":true},"type":{"type":"intrinsic","name":"boolean"},"parent":"0d27b082-2aab-5c13-820b-f564058945c6","rootDir":"/Users/jquense/src/hooks/src","tsconfig":"/Users/jquense/src/hooks/tsconfig.json","typedocs":[],"signatures":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/jquense/src/hooks/src/useMounted.ts"}],"parent":"388943ea-1a5c-520f-b3d1-e6f91cc69d26","rootDir":"/Users/jquense/src/hooks/src","tsconfig":"/Users/jquense/src/hooks/tsconfig.json","typedocs":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/jquense/src/hooks/src/useMounted.ts"}},"parent":"95d95a20-503c-546c-b8e6-1b3134175913","rootDir":"/Users/jquense/src/hooks/src","tsconfig":"/Users/jquense/src/hooks/tsconfig.json","typedocs":[],"signatures":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/jquense/src/hooks/src/useMounted.ts","description":{"id":"54249c26-366b-5fbb-a7da-4a39fff80e9d","parent":"388943ea-1a5c-520f-b3d1-e6f91cc69d26","mdx":{"id":"6440a291-a186-576d-b9b5-1ff300df0171","parent":"54249c26-366b-5fbb-a7da-4a39fff80e9d","frontmatter":{"title":""},"exports":{},"rawBody":"Track whether a component is current mounted. Generally less preferable than\nproperlly canceling effects so they don't run after a component is unmounted,\nbut helpful in cases where that isn't feasible, such as a `Promise` resolution.","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Track whether a component is current mounted. Generally less preferable than\\nproperlly canceling effects so they don't run after a component is unmounted,\\nbut helpful in cases where that isn't feasible, such as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" resolution.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"id":"0c17b3b9-7b04-56db-ad93-a1861cf2a831","parent":"54249c26-366b-5fbb-a7da-4a39fff80e9d","frontmatter":{"title":""},"excerpt":"","rawMarkdownBody":"Track whether a component is current mounted. Generally less preferable than\nproperlly canceling effects so they don't run after a component is unmounted,\nbut helpful in cases where that isn't feasible, such as a `Promise` resolution.","html":"<p>Track whether a component is current mounted. Generally less preferable than\nproperlly canceling effects so they don't run after a component is unmounted,\nbut helpful in cases where that isn't feasible, such as a <code>Promise</code> resolution.</p>"}},"returnsDescription":{"id":"403ab127-0d21-5fca-93ed-beeb244961cc","parent":"388943ea-1a5c-520f-b3d1-e6f91cc69d26","mdx":{"id":"3d333f41-ba99-52e6-8908-648f43ea29fc","parent":"403ab127-0d21-5fca-93ed-beeb244961cc","frontmatter":{"title":""},"exports":{},"rawBody":"a function that returns the current isMounted state of the component\n\n```ts\nconst [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n```\n","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"a function that returns the current isMounted state of the component\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const [data, setData] = useState(null)\\nconst isMounted = useMounted()\\n\\nuseEffect(() => {\\n  fetchdata().then((newData) => {\\n     if (isMounted()) {\\n       setData(newData);\\n     }\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"id":"e1b99c26-f2b4-5e1b-910e-c2d7245ab3ed","parent":"403ab127-0d21-5fca-93ed-beeb244961cc","frontmatter":{"title":""},"excerpt":"","rawMarkdownBody":"a function that returns the current isMounted state of the component\n\n```ts\nconst [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n```\n","html":"<p>a function that returns the current isMounted state of the component</p>\n<pre><code class=\"language-ts\">const [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n</code></pre>"}}}],"parent":"7e4c78e5-2fa3-5dad-b44e-b95fd3a37cd4","rootDir":"/Users/jquense/src/hooks/src","tsconfig":"/Users/jquense/src/hooks/tsconfig.json","typedocs":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/jquense/src/hooks/src/useMounted.ts"},"type":"hook","name":"useMounted","packageName":"@restart/hooks","importName":"import useMounted from '@restart/hooks/useMounted'","tags":[{"name":"returns","value":"a function that returns the current isMounted state of the component\n\n```ts\nconst [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n```"}],"example":null,"signatures":[{"kind":"function","name":"useMounted","description":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Track whether a component is current mounted. Generally less preferable than\\nproperlly canceling effects so they don't run after a component is unmounted,\\nbut helpful in cases where that isn't feasible, such as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" resolution.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"examples":[],"type":null,"params":null,"properties":null,"optional":false,"returns":[{"name":null,"description":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"a function that returns the current isMounted state of the component\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const [data, setData] = useState(null)\\nconst isMounted = useMounted()\\n\\nuseEffect(() => {\\n  fetchdata().then((newData) => {\\n     if (isMounted()) {\\n       setData(newData);\\n     }\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"optional":false,"type":{"name":null,"type":"FunctionType","elements":null,"expression":null,"applications":null}}],"members":{"static":null}}]}},"pageContext":{"nodeId":"ccd0438f-2a5b-5a1d-b0ba-038e32bb1a41","exampleId":null}}}